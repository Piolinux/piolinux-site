<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="keywords" content="jogos online, jogos web, cole√ß√£o de jogos, HTML, CSS, JavaScript, jokenpo, jogo da forca, jogo da cobrinha, blackjack, quebra-cabe√ßa, jogos cl√°ssicos">
    <link rel="canonical" href="https://piolinux.com/jogos-online.html">
    <meta name="author" content="Piolinux">
    <meta name="robots" content="index,nofollow">
    <title>Minha Cole√ß√£o Completa de Jogos</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Verdana', sans-serif;
        }
        body {
            background-color: #121212;
            color: #E0E0E0;
            text-align: center;
            padding: 20px;
        }
        h1 {
            color: #007BFF;
            margin-bottom: 10px;
        }
        h2 {
            color: #00BFFF;
            margin-bottom: 15px;
        }
        p {
            margin-bottom: 10px;
        }
        .game-container {
            border: 2px solid #333;
            padding: 20px;
            margin: 20px auto;
            max-width: 600px;
            background-color: #202020;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        canvas {
            border: 1px solid #444;
            background-color: #333;
            display: block;
            margin: 10px auto;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background-color: #007BFF;
            color: white;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #444;
            color: #888;
            cursor: not-allowed;
        }
        input[type="text"], input[type="number"] {
            padding: 8px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #555;
            background-color: #333;
            color: #E0E0E0;
        }
        #jokenpoResult, #guessResult, #hangmanMessage, #memoryMessage, #treasureMessage, #slidingPuzzleMessage, #typingResult, #platformerMessage, #blackjackMessage, #quizResult, #rpgText, #rpgBattleMessage {
            font-size: 1.2em;
            font-weight: bold;
            margin-top: 10px;
        }
        #memoryBoard {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            max-width: 400px;
            margin: auto;
        }
        #memoryBoard .card {
            background-color: #007BFF;
            color: white;
            padding: 20px;
            font-size: 2em;
            text-align: center;
            border-radius: 5px;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.3s;
        }
        #memoryBoard .card:hover {
            background-color: #0056b3;
        }
        .card {
            width: 50px;
            height: 70px;
            border: 1px solid #444;
            background-color: #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            border-radius: 5px;
        }
        #playerHand, #dealerHand {
            display: flex;
            justify-content: center;
            gap: 10px;
        }
    </style>
</head>
<body>

    <h1>Minha Cole√ß√£o Completa de Jogos</h1>
    
    <p>
        Seja bem-vindo(a)! Gosta de jogos desenvolvidos em JavaScript para se divertir? S√£o 22 jogos para uma divers√£o sem parar.

Para come√ßar ou jogar novamente, use o bot√£o "Reiniciar" de cada jogo. Divirta-se!    </p>

    <div class="game-container">
        <h2>1. Adivinhe o N√∫mero</h2>
        <p>Adivinhe um n√∫mero entre 1 e 100.</p>
        <input type="number" id="guessInput">
        <button onclick="checkGuess()">Adivinhar</button>
        <p id="guessResult"></p>
        <button onclick="resetGuessGame()">Reiniciar</button>
    </div>

    <div class="game-container">
        <h2>2. Jokenp√¥</h2>
        <p>Sua escolha:</p>
        <button onclick="playJokenpo('pedra')">Pedra</button>
        <button onclick="playJokenpo('papel')">Papel</button>
        <button onclick="playJokenpo('tesoura')">Tesoura</button>
        <p id="jokenpoResult"></p>
    </div>
    
    <div class="game-container">
        <h2>3. Jogo da Forca</h2>
        <p>Tente adivinhar a palavra secreta!</p>
        <p id="hangmanWord">_ _ _ _ _</p>
        <p>Letras erradas: <span id="hangmanWrong"></span></p>
        <canvas id="hangmanCanvas" width="200" height="200"></canvas>
        <input type="text" id="hangmanGuess" maxlength="1">
        <button onclick="checkHangmanGuess()">Adivinhar</button>
        <p id="hangmanMessage"></p>
        <button onclick="resetHangmanGame()">Reiniciar</button>
    </div>

    <div class="game-container">
        <h2>4. Jogo da Mem√≥ria</h2>
        <p>Clique nas cartas para encontrar os pares.</p>
        <div id="memoryBoard"></div>
        <p id="memoryMessage"></p>
        <button onclick="resetMemoryGame()">Reiniciar</button>
    </div>

    <div class="game-container">
        <h2>5. Ca√ßa ao Tesouro</h2>
        <p>Use as setas do teclado para se mover e encontrar o tesouro.</p>
        <canvas id="treasureCanvas" width="400" height="400"></canvas>
        <p id="treasureMessage"></p>
        <button onclick="resetTreasureGame()">Reiniciar</button>
    </div>
    
    <div class="game-container">
        <h2>6. Quebra-Cabe√ßa Deslizante</h2>
        <p>Clique em uma pe√ßa para mov√™-la para o espa√ßo vazio. Resolva o quebra-cabe√ßa!</p>
        <canvas id="slidingPuzzleCanvas" width="300" height="300"></canvas>
        <p id="slidingPuzzleMessage"></p>
        <button onclick="resetSlidingPuzzle()">Reiniciar</button>
    </div>

    <div class="game-container">
        <h2>7. Jogo da Cobrinha</h2>
        <p>Use as setas do teclado para controlar a cobrinha e comer a ma√ß√£.</p>
        <canvas id="snakeCanvas" width="400" height="400"></canvas>
        <p>Pontos: <span id="snakeScore">0</span></p>
        <button onclick="resetSnakeGame()">Reiniciar</button>
    </div>
    
    <div class="game-container">
        <h2>8. Jogo de Digita√ß√£o</h2>
        <p>Digite a palavra exibida o mais r√°pido que puder.</p>
        <p id="typingWord"></p>
        <input type="text" id="typingInput">
        <p id="typingResult"></p>
        <button onclick="startTypingGame()">Reiniciar</button>
    </div>
    
    <div class="game-container">
        <h2>9. Corrida de Carros</h2>
        <p>Use as setas do teclado para controlar o carro. Evite as paredes!</p>
        <canvas id="racingCanvas" width="400" height="400"></canvas>
        <button onclick="resetRacingGame()">Reiniciar</button>
    </div>
    
    <div class="game-container">
        <h2>10. Pong</h2>
        <p>Use as setas para mover sua barra e rebater a bolinha.</p>
        <canvas id="pongCanvas" width="600" height="400"></canvas>
        <p>Placar: <span id="pongScore">0</span></p>
        <button onclick="resetPongGame()">Reiniciar</button>
    </div>
    
    <div class="game-container">
        <h2>11. Arkanoid</h2>
        <p>Use as setas para mover a barra e destruir os blocos com a bolinha.</p>
        <canvas id="arkanoidCanvas" width="400" height="300"></canvas>
        <p>Pontos: <span id="arkanoidScore">0</span></p>
        <button onclick="resetArkanoidGame()">Reiniciar</button>
    </div>
    
    <div class="game-container">
        <h2>12. Jogo de Plataforma</h2>
        <p>Use as setas para mover e pular.</p>
        <canvas id="platformerCanvas" width="400" height="300"></canvas>
        <p id="platformerMessage"></p>
        <button onclick="resetPlatformerGame()">Reiniciar</button>
    </div>
    
    <div class="game-container">
        <h2>13. Nave Espacial</h2>
        <p>Use as setas para mover. A nave atira automaticamente nos inimigos!</p>
        <canvas id="spaceShooterCanvas" width="400" height="400"></canvas>
        <p>Pontos: <span id="spaceShooterScore">0</span></p>
        <button onclick="resetSpaceShooterGame()">Reiniciar</button>
    </div>

    <div class="game-container">
        <h2>14. Defesa de Torre</h2>
        <p>Clique no campo para construir torres. Destrua os inimigos!</p>
        <canvas id="towerDefenseCanvas" width="400" height="300"></canvas>
        <p>Dinheiro: <span id="towerDefenseMoney">100</span> | Inimigos: <span id="towerDefenseCount">0</span></p>
        <button onclick="resetTowerDefenseGame()">Reiniciar</button>
    </div>
    
    <div class="game-container">
        <h2>15. Blackjack</h2>
        <p id="blackjackMessage">Clique em "Novo Jogo" para come√ßar!</p>
        <div>
            <h3>Sua M√£o: <span id="playerScore">0</span></h3>
            <div id="playerHand"></div>
        </div>
        <div>
            <h3>M√£o do Computador: <span id="dealerScore">0</span></h3>
            <div id="dealerHand"></div>
        </div>
        <div>
            <button onclick="blackjackHit()" disabled>Pedir</button>
            <button onclick="blackjackStand()" disabled>Ficar</button>
        </div>
        <button onclick="resetBlackjackGame()">Novo Jogo</button>
    </div>
    
    <div class="game-container">
        <h2>16. Quiz</h2>
        <p id="quizQuestion">Clique em "Iniciar" para come√ßar.</p>
        <div id="quizOptions"></div>
        <p id="quizResult"></p>
        <button onclick="startQuizGame()">Iniciar</button>
    </div>
    
    <div class="game-container">
        <h2>17. RPG de Texto</h2>
        <p id="rpgText">Inicie sua aventura!</p>
        <div id="rpgOptions"></div>
        <button onclick="startRpgGame()">Iniciar</button>
    </div>

    <div class="game-container">
        <h2>18. Labirinto com Tempo</h2>
        <p>Use as setas para encontrar a sa√≠da (verde) em <span id="mazeTimer">60</span> segundos.</p>
        <canvas id="mazeCanvas" width="400" height="400"></canvas>
        <button onclick="resetMazeGame()">Reiniciar</button>
    </div>

    <div class="game-container">
        <h2>19. Quebra-Cabe√ßa de Cores</h2>
        <p>Clique em dois blocos para troc√°-los. Combine 3 ou mais da mesma cor!</p>
        <canvas id="colorPuzzleCanvas" width="300" height="300"></canvas>
        <p>Pontos: <span id="colorPuzzleScore">0</span></p>
        <button onclick="resetColorPuzzleGame()">Reiniciar</button>
    </div>

    <div class="game-container">
        <h2>20. Jogo de Cliques Ociosos</h2>
        <p>Clique para ganhar pontos, depois compre melhorias para ganhar pontos automaticamente!</p>
        <button id="clickerButton" onclick="clickerClick()">Pontos: <span id="clickerScore">0</span></button>
        <p>Pontos por segundo: <span id="sps">0</span></p>
        <button class="upgrade-btn" onclick="buyUpgrade(0)">Melhoria 1 (Custo: 10 | +1 SPS)</button>
        <button class="upgrade-btn" onclick="buyUpgrade(1)">Melhoria 2 (Custo: 50 | +5 SPS)</button>
        <button class="upgrade-btn" onclick="buyUpgrade(2)">Melhoria 3 (Custo: 200 | +20 SPS)</button>
        <button onclick="resetClickerGame()">Reiniciar</button>
    </div>

    <div class="game-container">
        <h2>21. Jogo de Ritmo</h2>
        <p>Acerte as notas com as teclas A, S, D, F.</p>
        <canvas id="rhythmCanvas" width="400" height="300"></canvas>
        <p>Pontos: <span id="rhythmScore">0</span></p>
        <button onclick="resetRhythmGame()">Reiniciar</button>
    </div>

    <div class="game-container">
        <h2>22. Batalha por Turnos</h2>
        <p id="rpgBattleMessage">Uma batalha √©pica come√ßou!</p>
        <div id="rpgBattleStats">
            <div>
                <h3>Her√≥i</h3>
                <p>HP: <span id="heroHP">100</span></p>
            </div>
            <div>
                <h3>Monstro</h3>
                <p>HP: <span id="monsterHP">150</span></p>
            </div>
        </div>
        <div>
            <button onclick="heroAttack()">Atacar</button>
            <button onclick="heroHeal()">Curar</button>
        </div>
        <button onclick="resetRpgBattleGame()">Reiniciar</button>
    </div>
    
    <script>
        //-----------------------------------
        // L√ìGICA DOS JOGOS (MODIFICADA PARA INICIAR APENAS COM O BOT√ÉO)
        //-----------------------------------
        
        // Jogo 1: Adivinhe o N√∫mero
        (function() {
            let secretNumber;
            function checkGuess() {
                let guess = parseInt(document.getElementById('guessInput').value);
                let result = document.getElementById('guessResult');
                if (guess === secretNumber) {
                    result.textContent = 'Parab√©ns, voc√™ acertou!';
                } else if (guess < secretNumber) {
                    result.textContent = 'O n√∫mero √© maior!';
                } else {
                    result.textContent = 'O n√∫mero √© menor!';
                }
            }
            function resetGuessGame() {
                secretNumber = Math.floor(Math.random() * 100) + 1;
                document.getElementById('guessInput').value = '';
                document.getElementById('guessResult').textContent = '';
            }
            window.checkGuess = checkGuess;
            window.resetGuessGame = resetGuessGame;
            // remove a chamada `resetGuessGame();` daqui para que o jogo n√£o comece automaticamente
        })();

        // Jogo 2: Jokenp√¥ (n√£o tem estado inicial, ent√£o n√£o precisa de reinicializa√ß√£o autom√°tica)
        (function() {
            function playJokenpo(playerChoice) {
                const choices = ['pedra', 'papel', 'tesoura'];
                const computerChoice = choices[Math.floor(Math.random() * 3)];
                let result = '';
                if (playerChoice === computerChoice) {
                    result = 'Empate!';
                } else if ((playerChoice === 'pedra' && computerChoice === 'tesoura') || (playerChoice === 'papel' && computerChoice === 'pedra') || (playerChoice === 'tesoura' && computerChoice === 'papel')) {
                    result = 'Voc√™ venceu!';
                } else {
                    result = 'Voc√™ perdeu.';
                }
                document.getElementById('jokenpoResult').textContent = `Voc√™ escolheu ${playerChoice}, o computador escolheu ${computerChoice}. ${result}`;
            }
            window.playJokenpo = playJokenpo;
        })();
        
        // Jogo 3: Jogo da Forca
        (function() {
            const words = ['javascript', 'programacao', 'desenvolvimento', 'html', 'canvas'];
            let secretWord, guessedLetters, incorrectGuesses;
            const canvas = document.getElementById('hangmanCanvas');
            const ctx = canvas.getContext('2d');

            function drawHangman() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.lineWidth = 2;
                if (incorrectGuesses.length > 0) { ctx.beginPath(); ctx.moveTo(10, 190); ctx.lineTo(190, 190); ctx.stroke(); }
                if (incorrectGuesses.length > 1) { ctx.beginPath(); ctx.moveTo(50, 190); ctx.lineTo(50, 10); ctx.stroke(); }
                if (incorrectGuesses.length > 2) { ctx.beginPath(); ctx.moveTo(50, 10); ctx.lineTo(150, 10); ctx.stroke(); }
                if (incorrectGuesses.length > 3) { ctx.beginPath(); ctx.moveTo(150, 10); ctx.lineTo(150, 40); ctx.stroke(); }
                if (incorrectGuesses.length > 4) { ctx.beginPath(); ctx.arc(150, 60, 20, 0, Math.PI * 2); ctx.stroke(); }
                if (incorrectGuesses.length > 5) { ctx.beginPath(); ctx.moveTo(150, 80); ctx.lineTo(150, 140); ctx.stroke(); }
                if (incorrectGuesses.length > 6) { ctx.beginPath(); ctx.moveTo(150, 90); ctx.lineTo(120, 120); ctx.stroke(); }
                if (incorrectGuesses.length > 7) { ctx.beginPath(); ctx.moveTo(150, 90); ctx.lineTo(180, 120); ctx.stroke(); }
                if (incorrectGuesses.length > 8) { ctx.beginPath(); ctx.moveTo(150, 140); ctx.lineTo(120, 170); ctx.stroke(); }
                if (incorrectGuesses.length > 9) { ctx.beginPath(); ctx.moveTo(150, 140); ctx.lineTo(180, 170); ctx.stroke(); }
            }

            function updateDisplay() {
                if (!secretWord) return;
                let display = '';
                for (let letter of secretWord) {
                    display += guessedLetters.includes(letter) ? letter + ' ' : '_ ';
                }
                document.getElementById('hangmanWord').textContent = display;
                document.getElementById('hangmanWrong').textContent = incorrectGuesses.join(', ');
                if (!display.includes('_')) {
                    document.getElementById('hangmanMessage').textContent = 'Parab√©ns, voc√™ venceu!';
                } else if (incorrectGuesses.length >= 10) {
                    document.getElementById('hangmanMessage').textContent = `Fim de Jogo! A palavra era: ${secretWord}`;
                }
            }

            function checkHangmanGuess() {
                if (!secretWord || incorrectGuesses.length >= 10 || !document.getElementById('hangmanGuess').value) return;
                const guess = document.getElementById('hangmanGuess').value.toLowerCase();
                document.getElementById('hangmanGuess').value = '';
                if (!guess || guessedLetters.includes(guess) || incorrectGuesses.includes(guess)) return;
                if (secretWord.includes(guess)) {
                    guessedLetters.push(guess);
                } else {
                    incorrectGuesses.push(guess);
                }
                drawHangman();
                updateDisplay();
            }

            function resetHangmanGame() {
                secretWord = words[Math.floor(Math.random() * words.length)];
                guessedLetters = [];
                incorrectGuesses = [];
                document.getElementById('hangmanMessage').textContent = '';
                document.getElementById('hangmanGuess').value = '';
                drawHangman();
                updateDisplay();
            }
            window.checkHangmanGuess = checkHangmanGuess;
            window.resetHangmanGame = resetHangmanGame;
            // remove a chamada `resetHangmanGame();`
        })();

        // Jogo 4: Jogo da Mem√≥ria
        (function() {
            const emojis = ['üçá', 'üçâ', 'üçä', 'üçã', 'üçå', 'üçç', 'üçé', 'üçê'];
            let cards, flippedCards, matchedPairs;
            const board = document.getElementById('memoryBoard');
            const message = document.getElementById('memoryMessage');
            
            function createBoard() {
                const gameEmojis = [...emojis, ...emojis].sort(() => Math.random() - 0.5);
                cards = gameEmojis.map((emoji, index) => ({ id: index, emoji, flipped: false, matched: false }));
                board.innerHTML = '';
                cards.forEach(card => {
                    const cardDiv = document.createElement('div');
                    cardDiv.className = 'card';
                    cardDiv.dataset.id = card.id;
                    cardDiv.textContent = '?';
                    cardDiv.addEventListener('click', () => flipCard(cardDiv));
                    board.appendChild(cardDiv);
                });
            }
            
            function flipCard(cardDiv) {
                const card = cards[cardDiv.dataset.id];
                if (flippedCards.length < 2 && !card.flipped && !card.matched) {
                    card.flipped = true;
                    cardDiv.textContent = card.emoji;
                    flippedCards.push(card);
                    if (flippedCards.length === 2) {
                        setTimeout(checkForMatch, 1000);
                    }
                }
            }

            function checkForMatch() {
                const [card1, card2] = flippedCards;
                const cardDiv1 = board.querySelector(`[data-id='${card1.id}']`);
                const cardDiv2 = board.querySelector(`[data-id='${card2.id}']`);
                
                if (card1.emoji === card2.emoji) {
                    card1.matched = true;
                    card2.matched = true;
                    cardDiv1.style.backgroundColor = cardDiv2.style.backgroundColor = '#90EE90';
                    matchedPairs++;
                    if (matchedPairs === emojis.length) {
                        message.textContent = 'Parab√©ns, voc√™ venceu!';
                    }
                } else {
                    card1.flipped = false;
                    card2.flipped = false;
                    cardDiv1.textContent = cardDiv2.textContent = '?';
                }
                flippedCards = [];
            }

            function resetMemoryGame() {
                flippedCards = [];
                matchedPairs = 0;
                message.textContent = '';
                createBoard();
            }
            window.resetMemoryGame = resetMemoryGame;
            // remove a chamada `resetMemoryGame();`
        })();

        // Jogo 5: Ca√ßa ao Tesouro
        (function() {
            const canvas = document.getElementById('treasureCanvas');
            const ctx = canvas.getContext('2d');
            const TILE_SIZE = 20;
            const MAP_SIZE = 20;
            let player, treasure;

            function drawMap() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (player) {
                    ctx.fillStyle = '#00BFFF';
                    ctx.fillRect(player.x * TILE_SIZE, player.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(treasure.x * TILE_SIZE, treasure.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }

            function checkWin() {
                if (player && player.x === treasure.x && player.y === treasure.y) {
                    document.getElementById('treasureMessage').textContent = 'Voc√™ encontrou o tesouro!';
                }
            }
            
            document.addEventListener('keydown', e => {
                if (player) {
                    if (e.key === 'ArrowUp' && player.y > 0) player.y--;
                    if (e.key === 'ArrowDown' && player.y < MAP_SIZE - 1) player.y++;
                    if (e.key === 'ArrowLeft' && player.x > 0) player.x--;
                    if (e.key === 'ArrowRight' && player.x < MAP_SIZE - 1) player.x++;
                    drawMap();
                    checkWin();
                }
            });

            function resetTreasureGame() {
                player = { x: 0, y: 0 };
                treasure = { x: Math.floor(Math.random() * MAP_SIZE), y: Math.floor(Math.random() * MAP_SIZE) };
                document.getElementById('treasureMessage').textContent = '';
                drawMap();
            }
            window.resetTreasureGame = resetTreasureGame;
            // remove a chamada `resetTreasureGame();`
        })();

        // Jogo 6: Quebra-Cabe√ßa Deslizante
        (function() {
            const canvas = document.getElementById('slidingPuzzleCanvas');
            const ctx = canvas.getContext('2d');
            const TILE_SIZE = 100;
            const BOARD_SIZE = 3;
            let board, solvedBoard;
            let message = document.getElementById('slidingPuzzleMessage');

            function drawBoard() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!board) return;
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        const tileValue = board[r][c];
                        if (tileValue !== 0) {
                            ctx.fillStyle = '#007BFF';
                            ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE - 2, TILE_SIZE - 2);
                            ctx.fillStyle = 'white';
                            ctx.font = '30px Verdana';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(tileValue, c * TILE_SIZE + TILE_SIZE / 2, r * TILE_SIZE + TILE_SIZE / 2);
                        }
                    }
                }
            }
            
            function createBoard() {
                board = [[1, 2, 3], [4, 5, 6], [7, 8, 0]];
                solvedBoard = JSON.parse(JSON.stringify(board));
            }

            function shuffleBoard() {
                if (!board) return;
                for (let i = 0; i < 1000; i++) {
                    const empty = findEmpty();
                    const moves = [];
                    if (empty.x > 0) moves.push({ x: empty.x - 1, y: empty.y });
                    if (empty.x < BOARD_SIZE - 1) moves.push({ x: empty.x + 1, y: empty.y });
                    if (empty.y > 0) moves.push({ x: empty.x, y: empty.y - 1 });
                    if (empty.y < BOARD_SIZE - 1) moves.push({ x: empty.x, y: empty.y + 1 });
                    const move = moves[Math.floor(Math.random() * moves.length)];
                    [board[empty.y][empty.x], board[move.y][move.x]] = [board[move.y][move.x], board[empty.y][empty.x]];
                }
            }
            
            function findEmpty() {
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (board[r][c] === 0) return { x: c, y: r };
                    }
                }
            }

            function moveTile(x, y) {
                if (!board) return;
                const empty = findEmpty();
                if (Math.abs(x - empty.x) + Math.abs(y - empty.y) === 1) {
                    [board[y][x], board[empty.y][empty.x]] = [board[empty.y][empty.x], board[y][x]];
                    drawBoard();
                    checkWin();
                }
            }

            function checkWin() {
                if (JSON.stringify(board) === JSON.stringify(solvedBoard)) {
                    message.textContent = 'Parab√©ns, voc√™ resolveu!';
                }
            }

            canvas.addEventListener('click', e => {
                if (!board) return;
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / TILE_SIZE);
                const y = Math.floor((e.clientY - rect.top) / TILE_SIZE);
                moveTile(x, y);
            });

            function resetSlidingPuzzle() {
                createBoard();
                shuffleBoard();
                drawBoard();
                message.textContent = '';
            }
            window.resetSlidingPuzzle = resetSlidingPuzzle;
            // remove a chamada `resetSlidingPuzzle();`
        })();

        // Jogo 7: Jogo da Cobrinha
        (function() {
            const canvas = document.getElementById('snakeCanvas');
            const ctx = canvas.getContext('2d');
            const TILE_SIZE = 20;
            let snake, food, direction, score, gameLoop;

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!snake) return;
                ctx.fillStyle = 'green';
                snake.forEach(segment => ctx.fillRect(segment.x, segment.y, TILE_SIZE, TILE_SIZE));
                ctx.fillStyle = 'red';
                ctx.fillRect(food.x, food.y, TILE_SIZE, TILE_SIZE);
            }

            function moveSnake() {
                const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };
                snake.unshift(head);
                if (head.x === food.x && head.y === food.y) {
                    score++;
                    document.getElementById('snakeScore').textContent = score;
                    generateFood();
                } else {
                    snake.pop();
                }
                checkCollision();
                draw();
            }

            function generateFood() {
                food = {
                    x: Math.floor(Math.random() * (canvas.width / TILE_SIZE)) * TILE_SIZE,
                    y: Math.floor(Math.random() * (canvas.height / TILE_SIZE)) * TILE_SIZE
                };
            }

            function checkCollision() {
                const head = snake[0];
                if (head.x < 0 || head.x >= canvas.width || head.y < 0 || head.y >= canvas.height || snake.slice(1).some(s => s.x === head.x && s.y === head.y)) {
                    clearInterval(gameLoop);
                    alert(`Fim de Jogo! Pontos: ${score}`);
                }
            }

            document.addEventListener('keydown', e => {
                if (!snake) return;
                if (e.key === 'ArrowUp' && direction.y === 0) direction = { x: 0, y: -TILE_SIZE };
                if (e.key === 'ArrowDown' && direction.y === 0) direction = { x: 0, y: TILE_SIZE };
                if (e.key === 'ArrowLeft' && direction.x === 0) direction = { x: -TILE_SIZE, y: 0 };
                if (e.key === 'ArrowRight' && direction.x === 0) direction = { x: TILE_SIZE, y: 0 };
            });

            function resetSnakeGame() {
                clearInterval(gameLoop);
                snake = [{ x: 200, y: 200 }];
                direction = { x: TILE_SIZE, y: 0 };
                score = 0;
                document.getElementById('snakeScore').textContent = score;
                generateFood();
                gameLoop = setInterval(moveSnake, 100);
                draw();
            }
            window.resetSnakeGame = resetSnakeGame;
            // remove a chamada `resetSnakeGame();`
        })();

        // Jogo 8: Jogo de Digita√ß√£o
        (function() {
            const words = ['javascript', 'programacao', 'desenvolvimento', 'html', 'canvas'];
            let currentWord, startTime;
            const wordDisplay = document.getElementById('typingWord');
            const input = document.getElementById('typingInput');
            const result = document.getElementById('typingResult');

            function startTypingGame() {
                currentWord = words[Math.floor(Math.random() * words.length)];
                wordDisplay.textContent = currentWord;
                input.value = '';
                input.focus();
                result.textContent = '';
                startTime = Date.now();
            }

            input.addEventListener('input', () => {
                if (!currentWord) return;
                if (input.value === currentWord) {
                    const elapsedTime = (Date.now() - startTime) / 1000;
                    result.textContent = `Parab√©ns! Voc√™ digitou em ${elapsedTime.toFixed(2)} segundos.`;
                    input.value = '';
                    setTimeout(startTypingGame, 1000);
                }
            });

            window.startTypingGame = startTypingGame;
            // remove a chamada `startTypingGame();`
        })();

        // Jogo 9: Corrida de Carros
        (function() {
            const canvas = document.getElementById('racingCanvas');
            const ctx = canvas.getContext('2d');
            let car, racingGameLoop;
            const walls = [
                { x: 0, y: 0, width: 400, height: 10 }, { x: 0, y: 0, width: 10, height: 400 },
                { x: 390, y: 0, width: 10, height: 400 }, { x: 0, y: 390, width: 400, height: 10 },
                { x: 100, y: 100, width: 200, height: 10 }, { x: 100, y: 100, width: 10, height: 200 },
                { x: 300, y: 100, width: 10, height: 200 }, { x: 100, y: 300, width: 200, height: 10 },
            ];

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!car) return;
                ctx.fillStyle = '#202020';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'gray';
                ctx.fillRect(10, 10, 380, 380);
                ctx.fillStyle = 'black';
                walls.forEach(w => ctx.fillRect(w.x, w.y, w.width, w.height));
                ctx.fillStyle = 'red';
                ctx.save();
                ctx.translate(car.x, car.y);
                ctx.rotate(car.angle * Math.PI / 180);
                ctx.fillRect(-10, -20, 20, 40);
                ctx.restore();
            }

            function update() {
                if (!car) return;
                car.x += car.speed * Math.cos(car.angle * Math.PI / 180);
                car.y += car.speed * Math.sin(car.angle * Math.PI / 180);
                car.speed *= 0.98;
                checkCollision();
                draw();
            }

            function checkCollision() {
                const carLeft = car.x - 10, carRight = car.x + 10, carTop = car.y - 20, carBottom = car.y + 20;
                for (let w of walls) {
                    if (carRight > w.x && carLeft < w.x + w.width && carBottom > w.y && carTop < w.y + w.height) {
                        clearInterval(racingGameLoop);
                        alert('Bateu! Fim de jogo.');
                        car = null;
                        return;
                    }
                }
                if (carLeft < 0 || carRight > canvas.width || carTop < 0 || carBottom > canvas.height) {
                    clearInterval(racingGameLoop);
                    alert('Bateu na parede! Fim de jogo.');
                    car = null;
                }
            }
            
            document.addEventListener('keydown', e => {
                if (!car) return;
                if (e.key === 'ArrowUp') car.speed = 5;
                if (e.key === 'ArrowDown') car.speed = -3;
                if (e.key === 'ArrowLeft') car.angle -= 5;
                if (e.key === 'ArrowRight') car.angle += 5;
            });

            function resetRacingGame() {
                clearInterval(racingGameLoop);
                car = { x: 50, y: 50, speed: 0, angle: 90 };
                racingGameLoop = setInterval(update, 20);
                draw();
            }
            window.resetRacingGame = resetRacingGame;
            // remove a chamada `resetRacingGame();`
        })();

        // Jogo 10: Pong
        (function() {
            const canvas = document.getElementById('pongCanvas');
            const ctx = canvas.getContext('2d');
            let ball, paddle1, paddle2, score, pongGameLoop;

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!ball) return;
                ctx.fillStyle = 'white';
                ctx.fillRect(paddle1.x, paddle1.y, paddle1.width, paddle1.height);
                ctx.fillRect(paddle2.x, paddle2.y, paddle2.width, paddle2.height);
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            function update() {
                if (!ball) return;
                ball.x += ball.velocityX;
                ball.y += ball.velocityY;

                if (ball.y - ball.radius < 0 || ball.y + ball.radius > canvas.height) {
                    ball.velocityY = -ball.velocityY;
                }

                if (ball.x - ball.radius < paddle1.x + paddle1.width && ball.y > paddle1.y && ball.y < paddle1.y + paddle1.height) {
                    ball.velocityX = -ball.velocityX;
                }
                if (ball.x + ball.radius > paddle2.x && ball.y > paddle2.y && ball.y < paddle2.y + paddle2.height) {
                    ball.velocityX = -ball.velocityX;
                }

                if (ball.x < 0) {
                    score++;
                    document.getElementById('pongScore').textContent = score;
                    resetBall();
                }
                if (ball.x > canvas.width) {
                    clearInterval(pongGameLoop);
                    alert('Fim de Jogo! Voc√™ perdeu.');
                }
                
                paddle2.y = ball.y - paddle2.height / 2;
                draw();
            }

            function resetBall() {
                ball = { x: canvas.width / 2, y: canvas.height / 2, radius: 10, velocityX: 5, velocityY: 5 };
            }

            document.addEventListener('keydown', e => {
                if (!paddle1) return;
                if (e.key === 'ArrowUp' && paddle1.y > 0) paddle1.y -= 20;
                if (e.key === 'ArrowDown' && paddle1.y < canvas.height - paddle1.height) paddle1.y += 20;
            });

            function resetPongGame() {
                clearInterval(pongGameLoop);
                ball = { x: canvas.width / 2, y: canvas.height / 2, radius: 10, velocityX: 5, velocityY: 5 };
                paddle1 = { x: 10, y: canvas.height / 2 - 50, width: 10, height: 100 };
                paddle2 = { x: canvas.width - 20, y: canvas.height / 2 - 50, width: 10, height: 100 };
                score = 0;
                document.getElementById('pongScore').textContent = score;
                pongGameLoop = setInterval(update, 20);
                draw();
            }
            window.resetPongGame = resetPongGame;
            // remove a chamada `resetPongGame();`
        })();

        // Jogo 11: Arkanoid
        (function() {
            const canvas = document.getElementById('arkanoidCanvas');
            const ctx = canvas.getContext('2d');
            let ball, paddle, bricks, score, arkanoidGameLoop;
            
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!ball) return;
                ctx.fillStyle = '#eee';
                ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();

                bricks.forEach(row => {
                    row.forEach(brick => {
                        if (brick.visible) {
                            ctx.fillStyle = brick.color;
                            ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                        }
                    });
                });
            }

            function update() {
                if (!ball) return;
                ball.x += ball.velocityX;
                ball.y += ball.velocityY;

                if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
                    ball.velocityX = -ball.velocityX;
                }
                if (ball.y - ball.radius < 0) {
                    ball.velocityY = -ball.velocityY;
                }
                
                if (ball.x > paddle.x && ball.x < paddle.x + paddle.width && ball.y + ball.radius > paddle.y) {
                    ball.velocityY = -ball.velocityY;
                }
                
                bricks.forEach(row => {
                    row.forEach(brick => {
                        if (brick.visible) {
                            if (ball.x > brick.x && ball.x < brick.x + brick.width && ball.y > brick.y && ball.y < brick.y + brick.height) {
                                ball.velocityY = -ball.velocityY;
                                brick.visible = false;
                                score += 10;
                                document.getElementById('arkanoidScore').textContent = score;
                            }
                        }
                    });
                });
                
                if (ball.y + ball.radius > canvas.height) {
                    clearInterval(arkanoidGameLoop);
                    alert(`Fim de Jogo! Pontos: ${score}`);
                }
                
                draw();
            }
            
            document.addEventListener('keydown', e => {
                if (!paddle) return;
                if (e.key === 'ArrowLeft' && paddle.x > 0) paddle.x -= 20;
                if (e.key === 'ArrowRight' && paddle.x < canvas.width - paddle.width) paddle.x += 20;
            });

            function resetArkanoidGame() {
                clearInterval(arkanoidGameLoop);
                ball = { x: canvas.width / 2, y: canvas.height - 30, radius: 10, velocityX: 4, velocityY: -4 };
                paddle = { x: canvas.width / 2 - 40, y: canvas.height - 20, width: 80, height: 10 };
                bricks = [];
                score = 0;
                document.getElementById('arkanoidScore').textContent = score;

                for (let r = 0; r < 5; r++) {
                    bricks[r] = [];
                    for (let c = 0; c < 8; c++) {
                        bricks[r][c] = {
                            x: 10 + c * 50,
                            y: 10 + r * 20,
                            width: 40,
                            height: 15,
                            visible: true,
                            color: `hsl(${r * 360 / 5}, 70%, 50%)`
                        };
                    }
                }
                
                arkanoidGameLoop = setInterval(update, 20);
                draw();
            }
            window.resetArkanoidGame = resetArkanoidGame;
            // remove a chamada `resetArkanoidGame();`
        })();

        // Jogo 12: Jogo de Plataforma
        (function() {
            const canvas = document.getElementById('platformerCanvas');
            const ctx = canvas.getContext('2d');
            let player, platforms, gravity, velocityY, platformerGameLoop;

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!player) return;
                ctx.fillStyle = 'blue';
                ctx.fillRect(player.x, player.y, player.width, player.height);
                ctx.fillStyle = 'green';
                platforms.forEach(p => ctx.fillRect(p.x, p.y, p.width, p.height));
            }

            function update() {
                if (!player) return;
                velocityY += gravity;
                player.y += velocityY;

                let onGround = false;
                platforms.forEach(p => {
                    if (player.x < p.x + p.width && player.x + player.width > p.x && player.y + player.height > p.y && player.y + player.height < p.y + p.height + 10) {
                        player.y = p.y - player.height;
                        velocityY = 0;
                        onGround = true;
                    }
                });

                if (player.y > canvas.height) {
                    clearInterval(platformerGameLoop);
                    document.getElementById('platformerMessage').textContent = 'Fim de Jogo! Voc√™ caiu.';
                }

                draw();
            }

            document.addEventListener('keydown', e => {
                if (!player) return;
                if (e.key === 'ArrowLeft') player.x -= 10;
                if (e.key === 'ArrowRight') player.x += 10;
                if (e.key === 'ArrowUp' && velocityY === 0) {
                    velocityY = -20;
                }
            });

            function resetPlatformerGame() {
                clearInterval(platformerGameLoop);
                player = { x: 50, y: 150, width: 20, height: 20 };
                platforms = [
                    { x: 0, y: 280, width: 400, height: 20 },
                    { x: 100, y: 200, width: 100, height: 20 },
                    { x: 250, y: 150, width: 100, height: 20 }
                ];
                gravity = 1;
                velocityY = 0;
                document.getElementById('platformerMessage').textContent = '';
                platformerGameLoop = setInterval(update, 20);
                draw();
            }
            window.resetPlatformerGame = resetPlatformerGame;
            // remove a chamada `resetPlatformerGame();`
        })();

        // Jogo 13: Nave Espacial
        (function() {
            const canvas = document.getElementById('spaceShooterCanvas');
            const ctx = canvas.getContext('2d');
            let player, enemies, bullets, score, spaceShooterLoop;

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!player) return;
                ctx.fillStyle = 'blue';
                ctx.fillRect(player.x, player.y, player.width, player.height);
                
                ctx.fillStyle = 'red';
                enemies.forEach(e => ctx.fillRect(e.x, e.y, e.width, e.height));
                
                ctx.fillStyle = 'yellow';
                bullets.forEach(b => ctx.fillRect(b.x, b.y, b.width, b.height));
            }

            function update() {
                if (!player) return;
                enemies.forEach(e => e.y += 1);
                bullets.forEach(b => b.y -= 5);

                bullets = bullets.filter(b => b.y > 0);
                enemies = enemies.filter(e => e.y < canvas.height);

                for (let b of bullets) {
                    for (let e of enemies) {
                        if (b.x > e.x && b.x < e.x + e.width && b.y > e.y && b.y < e.y + e.height) {
                            score++;
                            document.getElementById('spaceShooterScore').textContent = score;
                            bullets.splice(bullets.indexOf(b), 1);
                            enemies.splice(enemies.indexOf(e), 1);
                            break;
                        }
                    }
                }
                
                if (Math.random() < 0.05) {
                    enemies.push({ x: Math.random() * (canvas.width - 20), y: 0, width: 20, height: 20 });
                }

                draw();
            }

            document.addEventListener('keydown', e => {
                if (!player) return;
                if (e.key === 'ArrowLeft' && player.x > 0) player.x -= 10;
                if (e.key === 'ArrowRight' && player.x < canvas.width - player.width) player.x += 10;
            });

            function fire() {
                bullets.push({ x: player.x + player.width / 2, y: player.y, width: 5, height: 10 });
            }

            function resetSpaceShooterGame() {
                clearInterval(spaceShooterLoop);
                player = { x: canvas.width / 2 - 20, y: canvas.height - 50, width: 40, height: 40 };
                enemies = [];
                bullets = [];
                score = 0;
                document.getElementById('spaceShooterScore').textContent = score;
                spaceShooterLoop = setInterval(() => {
                    update();
                    fire();
                }, 50);
                draw();
            }
            window.resetSpaceShooterGame = resetSpaceShooterGame;
            // remove a chamada `resetSpaceShooterGame();`
        })();

        // Jogo 14: Defesa de Torre
        (function() {
            const canvas = document.getElementById('towerDefenseCanvas');
            const ctx = canvas.getContext('2d');
            let towers, enemies, money, towerDefenseLoop;

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!towers) return;
                ctx.fillStyle = '#654321';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                towers.forEach(t => {
                    ctx.fillStyle = 'blue';
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, 15, 0, Math.PI * 2);
                    ctx.fill();
                });

                enemies.forEach(e => {
                    ctx.fillStyle = 'red';
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, 10, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            function update() {
                if (!towers) return;
                enemies.forEach(e => e.x += 1);

                enemies = enemies.filter(e => {
                    if (e.x > canvas.width) {
                        alert('Inimigo passou! Fim de jogo.');
                        clearInterval(towerDefenseLoop);
                        return false;
                    }
                    return true;
                });
                document.getElementById('towerDefenseCount').textContent = enemies.length;
                draw();
            }

            canvas.addEventListener('click', e => {
                if (!towers) return;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (money >= 50) {
                    towers.push({ x, y });
                    money -= 50;
                    document.getElementById('towerDefenseMoney').textContent = money;
                    draw();
                }
            });

            function spawnEnemy() {
                enemies.push({ x: 0, y: Math.random() * canvas.height });
            }

            function resetTowerDefenseGame() {
                clearInterval(towerDefenseLoop);
                towers = [];
                enemies = [];
                money = 100;
                document.getElementById('towerDefenseMoney').textContent = money;
                document.getElementById('towerDefenseCount').textContent = enemies.length;
                towerDefenseLoop = setInterval(update, 50);
                setInterval(spawnEnemy, 2000);
                draw();
            }
            window.resetTowerDefenseGame = resetTowerDefenseGame;
            // remove a chamada `resetTowerDefenseGame();`
        })();

        // Jogo 15: Blackjack
        (function() {
            const suits = ['‚ô†Ô∏è', '‚ô•Ô∏è', '‚ô¶Ô∏è', '‚ô£Ô∏è'];
            const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
            let deck, playerHand, dealerHand, playerScore, dealerScore;

            function createDeck() {
                let deck = [];
                for (let suit of suits) {
                    for (let rank of ranks) {
                        deck.push({ rank, suit });
                    }
                }
                return deck;
            }

            function getCardValue(card) {
                if (['J', 'Q', 'K'].includes(card.rank)) return 10;
                if (card.rank === 'A') return 11;
                return parseInt(card.rank);
            }

            function calculateScore(hand) {
                let score = hand.reduce((sum, card) => sum + getCardValue(card), 0);
                let aces = hand.filter(card => card.rank === 'A').length;
                while (score > 21 && aces > 0) {
                    score -= 10;
                    aces--;
                }
                return score;
            }

            function dealCard(hand) {
                const card = deck.pop();
                hand.push(card);
                return card;
            }

            function updateDisplay() {
                document.getElementById('playerHand').innerHTML = playerHand.map(c => `<div class="card">${c.rank}${c.suit}</div>`).join('');
                document.getElementById('dealerHand').innerHTML = dealerHand.map((c, i) => `<div class="card">${i === 0 ? '?' : c.rank + c.suit}</div>`).join('');
                document.getElementById('playerScore').textContent = calculateScore(playerHand);
                document.getElementById('dealerScore').textContent = '??';
            }

            function resetBlackjackGame() {
                deck = createDeck();
                deck.sort(() => Math.random() - 0.5);
                playerHand = [];
                dealerHand = [];
                dealCard(playerHand);
                dealCard(dealerHand);
                dealCard(playerHand);
                dealCard(dealerHand);
                document.getElementById('blackjackMessage').textContent = 'Boa sorte!';
                document.getElementById('playerScore').textContent = calculateScore(playerHand);
                updateDisplay();
                document.querySelector('button[onclick="blackjackHit()"]').disabled = false;
                document.querySelector('button[onclick="blackjackStand()"]').disabled = false;
            }

            function blackjackHit() {
                dealCard(playerHand);
                playerScore = calculateScore(playerHand);
                document.getElementById('playerScore').textContent = playerScore;
                document.getElementById('playerHand').innerHTML += `<div class="card">${playerHand[playerHand.length - 1].rank}${playerHand[playerHand.length - 1].suit}</div>`;
                if (playerScore > 21) {
                    document.getElementById('blackjackMessage').textContent = 'Voc√™ estourou! Fim de jogo.';
                    endGame();
                }
            }

            function blackjackStand() {
                while (calculateScore(dealerHand) < 17) {
                    dealCard(dealerHand);
                }
                endGame();
            }

            function endGame() {
                document.querySelector('button[onclick="blackjackHit()"]').disabled = true;
                document.querySelector('button[onclick="blackjackStand()"]').disabled = true;
                playerScore = calculateScore(playerHand);
                dealerScore = calculateScore(dealerHand);
                document.getElementById('dealerScore').textContent = dealerScore;
                document.getElementById('dealerHand').innerHTML = dealerHand.map(c => `<div class="card">${c.rank}${c.suit}</div>`).join('');
                if (playerScore > 21) {
                    document.getElementById('blackjackMessage').textContent = 'Voc√™ estourou! Voc√™ perdeu.';
                } else if (dealerScore > 21 || playerScore > dealerScore) {
                    document.getElementById('blackjackMessage').textContent = 'Parab√©ns, voc√™ venceu!';
                } else if (playerScore < dealerScore) {
                    document.getElementById('blackjackMessage').textContent = 'O computador venceu.';
                } else {
                    document.getElementById('blackjackMessage').textContent = 'Empate!';
                }
            }

            window.resetBlackjackGame = resetBlackjackGame;
            window.blackjackHit = blackjackHit;
            window.blackjackStand = blackjackStand;
            // remove a chamada `resetBlackjackGame();`
        })();

        // Jogo 16: Quiz
        (function() {
            const questions = [
                { q: 'Qual a capital do Brasil?', a: 'Bras√≠lia', options: ['S√£o Paulo', 'Rio de Janeiro', 'Bras√≠lia', 'Belo Horizonte'] },
                { q: 'Qual o ano do descobrimento do Brasil?', a: '1500', options: ['1492', '1500', '1600', '1822'] }
            ];
            let currentQuestionIndex;
            const quizQuestion = document.getElementById('quizQuestion');
            const quizOptions = document.getElementById('quizOptions');
            const quizResult = document.getElementById('quizResult');

            function startQuizGame() {
                currentQuestionIndex = 0;
                quizResult.textContent = '';
                showQuestion();
            }

            function showQuestion() {
                if (currentQuestionIndex >= questions.length) {
                    quizResult.textContent = 'Parab√©ns, voc√™ completou o quiz!';
                    quizQuestion.textContent = '';
                    quizOptions.innerHTML = '';
                    return;
                }
                const q = questions[currentQuestionIndex];
                quizQuestion.textContent = q.q;
                quizOptions.innerHTML = '';
                q.options.forEach(option => {
                    const button = document.createElement('button');
                    button.textContent = option;
                    button.onclick = () => checkAnswer(option);
                    quizOptions.appendChild(button);
                });
            }

            function checkAnswer(answer) {
                if (answer === questions[currentQuestionIndex].a) {
                    quizResult.textContent = 'Correto!';
                    currentQuestionIndex++;
                    setTimeout(showQuestion, 1000);
                } else {
                    quizResult.textContent = 'Incorreto, tente novamente.';
                }
            }

            window.startQuizGame = startQuizGame;
            // remove a chamada `startQuizGame();`
        })();
        
        // Jogo 17: RPG de Texto
        (function() {
            const story = {
                start: {
                    text: 'Voc√™ acorda em uma floresta escura. O que voc√™ faz?',
                    options: [{ text: 'Ir para o norte', next: 'north' }, { text: 'Ir para o leste', next: 'east' }]
                },
                north: {
                    text: 'Voc√™ encontra um rio. Tentar nadar ou seguir o caminho?',
                    options: [{ text: 'Nadar', next: 'swim' }, { text: 'Seguir o caminho', next: 'path' }]
                },
                east: {
                    text: 'Voc√™ encontra uma caverna. Entrar ou continuar?',
                    options: [{ text: 'Entrar', next: 'cave' }, { text: 'Continuar', next: 'continue' }]
                },
                swim: { text: 'Voc√™ √© levado pela correnteza. Fim de jogo.', options: [{ text: 'Reiniciar', next: 'start' }] },
                path: { text: 'Voc√™ encontra uma cabana. Parab√©ns, voc√™ venceu!', options: [{ text: 'Reiniciar', next: 'start' }] },
                cave: { text: 'Um monstro te ataca. Fim de jogo.', options: [{ text: 'Reiniciar', next: 'start' }] },
                continue: { text: 'Voc√™ se perde na floresta. Fim de jogo.', options: [{ text: 'Reiniciar', next: 'start' }] }
            };
            let currentState;
            const rpgText = document.getElementById('rpgText');
            const rpgOptions = document.getElementById('rpgOptions');

            function startRpgGame() {
                currentState = story.start;
                renderState();
            }

            function renderState() {
                rpgText.textContent = currentState.text;
                rpgOptions.innerHTML = '';
                currentState.options.forEach(option => {
                    const button = document.createElement('button');
                    button.textContent = option.text;
                    button.onclick = () => chooseOption(option.next);
                    rpgOptions.appendChild(button);
                });
            }

            function chooseOption(nextState) {
                currentState = story[nextState];
                renderState();
            }

            window.startRpgGame = startRpgGame;
            // remove a chamada `startRpgGame();`
        })();

        // Jogo 18: Labirinto com Tempo
        (function() {
            const canvas = document.getElementById('mazeCanvas');
            const ctx = canvas.getContext('2d');
            const TILE_SIZE = 20;
            const MAZE_SIZE = 20;
            let maze, player, timer, mazeGameLoop;
            const exit = { x: MAZE_SIZE - 2, y: MAZE_SIZE - 2 };

            function generateMaze(size) {
                let maze = Array.from({ length: size }, () => Array(size).fill(1));
                let stack = [{ x: 1, y: 1 }];
                maze[1][1] = 0;
                const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

                while (stack.length > 0) {
                    let { x, y } = stack.pop();
                    let neighbors = directions.map(([dx, dy]) => ({ x: x + dx * 2, y: y + dy * 2 })).filter(({ x, y }) => x > 0 && x < size - 1 && y > 0 && y < size - 1 && maze[y][x] === 1);
                    if (neighbors.length > 0) {
                        stack.push({ x, y });
                        let neighbor = neighbors[Math.floor(Math.random() * neighbors.length)];
                        maze[(y + neighbor.y) / 2][(x + neighbor.x) / 2] = 0;
                        maze[neighbor.y][neighbor.x] = 0;
                        stack.push(neighbor);
                    }
                }
                return maze;
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!maze) return;
                for (let y = 0; y < MAZE_SIZE; y++) {
                    for (let x = 0; x < MAZE_SIZE; x++) {
                        ctx.fillStyle = maze[y][x] === 1 ? '#333' : '#fff';
                        ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
                ctx.fillStyle = 'green';
                ctx.fillRect(exit.x * TILE_SIZE, exit.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                ctx.fillStyle = 'blue';
                ctx.fillRect(player.x * TILE_SIZE, player.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }

            function checkWin() {
                if (player.x === exit.x && player.y === exit.y) {
                    clearInterval(mazeGameLoop);
                    alert('Parab√©ns, voc√™ encontrou a sa√≠da!');
                }
            }

            document.addEventListener('keydown', e => {
                if (!player) return;
                let newX = player.x, newY = player.y;
                if (e.key === 'ArrowUp') newY--;
                if (e.key === 'ArrowDown') newY++;
                if (e.key === 'ArrowLeft') newX--;
                if (e.key === 'ArrowRight') newX++;

                if (maze[newY] && maze[newY][newX] === 0) {
                    player.x = newX;
                    player.y = newY;
                    draw();
                    checkWin();
                }
            });

            function startTimer() {
                timer = 60;
                document.getElementById('mazeTimer').textContent = timer;
                mazeGameLoop = setInterval(() => {
                    timer--;
                    document.getElementById('mazeTimer').textContent = timer;
                    if (timer <= 0) {
                        clearInterval(mazeGameLoop);
                        alert('Tempo esgotado! Fim de jogo.');
                    }
                }, 1000);
            }

            function resetMazeGame() {
                clearInterval(mazeGameLoop);
                maze = generateMaze(MAZE_SIZE);
                player = { x: 1, y: 1 };
                startTimer();
                draw();
            }
            window.resetMazeGame = resetMazeGame;
            // remove a chamada `resetMazeGame();`
        })();

        // Jogo 19: Quebra-Cabe√ßa de Cores
        (function() {
            const canvas = document.getElementById('colorPuzzleCanvas');
            const ctx = canvas.getContext('2d');
            const GRID_SIZE = 8;
            const TILE_SIZE = 300 / GRID_SIZE;
            const colors = ['red', 'green', 'blue', 'yellow', 'purple', 'orange'];
            let board, selectedTile, score, colorPuzzleLoop;

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!board) return;
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        ctx.fillStyle = board[r][c];
                        ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }

            function fillBoard() {
                board = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(null));
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        board[r][c] = colors[Math.floor(Math.random() * colors.length)];
                    }
                }
            }

            canvas.addEventListener('click', e => {
                if (!board) return;
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / TILE_SIZE);
                const y = Math.floor((e.clientY - rect.top) / TILE_SIZE);
                
                if (!selectedTile) {
                    selectedTile = { x, y };
                } else {
                    const dx = Math.abs(x - selectedTile.x);
                    const dy = Math.abs(y - selectedTile.y);
                    if (dx + dy === 1) {
                        [board[y][x], board[selectedTile.y][selectedTile.x]] = [board[selectedTile.y][selectedTile.x], board[y][x]];
                        selectedTile = null;
                        draw();
                    } else {
                        selectedTile = null;
                    }
                }
            });

            function resetColorPuzzleGame() {
                clearInterval(colorPuzzleLoop);
                fillBoard();
                score = 0;
                document.getElementById('colorPuzzleScore').textContent = score;
                draw();
            }
            window.resetColorPuzzleGame = resetColorPuzzleGame;
            // remove a chamada `resetColorPuzzleGame();`
        })();

        // Jogo 20: Jogo de Cliques Ociosos
        (function() {
            let score, sps, upgrades;
            const scoreDisplay = document.getElementById('clickerScore');
            const spsDisplay = document.getElementById('sps');

            function updateDisplay() {
                scoreDisplay.textContent = Math.floor(score);
                spsDisplay.textContent = sps;
            }

            function clickerClick() {
                score++;
                updateDisplay();
            }

            function buyUpgrade(index) {
                const upgrade = upgrades[index];
                if (score >= upgrade.cost) {
                    score -= upgrade.cost;
                    sps += upgrade.sps;
                    upgrade.cost *= 2;
                    updateDisplay();
                }
            }

            function updateGame() {
                score += sps;
                updateDisplay();
            }
            
            function resetClickerGame() {
                score = 0;
                sps = 0;
                upgrades = [
                    { cost: 10, sps: 1 },
                    { cost: 50, sps: 5 },
                    { cost: 200, sps: 20 }
                ];
                updateDisplay();
                setInterval(updateGame, 1000);
            }
            window.resetClickerGame = resetClickerGame;
            window.clickerClick = clickerClick;
            window.buyUpgrade = buyUpgrade;
            // remove a chamada `resetClickerGame();`
        })();

        // Jogo 21: Jogo de Ritmo
        (function() {
            const canvas = document.getElementById('rhythmCanvas');
            const ctx = canvas.getContext('2d');
            let notes, rhythmScore, rhythmGameLoop;
            const keys = { 'a': 50, 's': 150, 'd': 250, 'f': 350 };

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!notes) return;
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                for (let key in keys) {
                    ctx.fillStyle = 'gray';
                    ctx.fillRect(keys[key] - 25, canvas.height - 50, 50, 50);
                }
                
                notes.forEach(note => {
                    ctx.fillStyle = 'blue';
                    ctx.fillRect(note.x - 10, note.y, 20, 20);
                });
            }

            function update() {
                if (!notes) return;
                notes.forEach(note => note.y += 2);
                
                notes = notes.filter(note => note.y < canvas.height - 50);
                
                if (Math.random() < 0.1) {
                    const key = Object.keys(keys)[Math.floor(Math.random() * 4)];
                    notes.push({ x: keys[key], y: -20, key });
                }
                draw();
            }

            document.addEventListener('keydown', e => {
                if (!notes) return;
                const key = e.key.toLowerCase();
                const note = notes.find(n => n.key === key && n.y > canvas.height - 70);
                if (note) {
                    rhythmScore += 10;
                    document.getElementById('rhythmScore').textContent = rhythmScore;
                    notes.splice(notes.indexOf(note), 1);
                }
            });

            function resetRhythmGame() {
                clearInterval(rhythmGameLoop);
                notes = [];
                rhythmScore = 0;
                document.getElementById('rhythmScore').textContent = rhythmScore;
                rhythmGameLoop = setInterval(update, 20);
                draw();
            }
            window.resetRhythmGame = resetRhythmGame;
            // remove a chamada `resetRhythmGame();`
        })();

        // Jogo 22: Batalha por Turnos
        (function() {
            let hero, monster;
            const heroHP = document.getElementById('heroHP');
            const monsterHP = document.getElementById('monsterHP');
            const message = document.getElementById('rpgBattleMessage');

            function updateDisplay() {
                if (!hero) return;
                heroHP.textContent = hero.hp;
                monsterHP.textContent = monster.hp;
            }

            function heroAttack() {
                if (!hero) return;
                const damage = Math.floor(Math.random() * 20) + 10;
                monster.hp -= damage;
                message.textContent = `Voc√™ atacou e causou ${damage} de dano!`;
                if (monster.hp <= 0) {
                    message.textContent = 'Voc√™ derrotou o monstro!';
                    hero = null;
                } else {
                    setTimeout(monsterAttack, 1000);
                }
                updateDisplay();
            }

            function heroHeal() {
                if (!hero) return;
                const heal = Math.floor(Math.random() * 15) + 5;
                hero.hp += heal;
                message.textContent = `Voc√™ se curou e recuperou ${heal} de HP!`;
                setTimeout(monsterAttack, 1000);
                updateDisplay();
            }

            function monsterAttack() {
                if (!hero) return;
                const damage = Math.floor(Math.random() * 15) + 5;
                hero.hp -= damage;
                message.textContent += ` O monstro te atacou e causou ${damage} de dano!`;
                if (hero.hp <= 0) {
                    message.textContent = 'Voc√™ foi derrotado. Fim de jogo!';
                    hero = null;
                }
                updateDisplay();
            }
            
            function resetRpgBattleGame() {
                hero = { hp: 100 };
                monster = { hp: 150 };
                message.textContent = 'Uma nova batalha come√ßou!';
                updateDisplay();
            }

            window.heroAttack = heroAttack;
            window.heroHeal = heroHeal;
            window.resetRpgBattleGame = resetRpgBattleGame;
            // remove a chamada `resetRpgBattleGame();`
        })();
    </script>
    <footer>
  Site criado com muito terminal e memes! Acesse:
  <a href="/politica-de-privacidade.html">Pol√≠tica de Privacidade</a> |
  <a href="/termos-de-uso.html">Termos de Uso</a>
</footer>
    </body>
</html>
